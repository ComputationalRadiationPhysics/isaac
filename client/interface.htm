<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>ISAAC Control Page</title>
</head>
<style>
    * {
      font-family: sans-serif;
    }
</style>
<body>
<script src="jscolor.js"></script>
<h3>Preview and camera setting</h3>
<p>Usage:
<ul>
<li>Left click + Mouse movement: Change view angle</li>
<li>Right/Middle click + Mouse movement: Change position</li>
<li>Mousewheel: zoom</li>
</ul>
<form>
	Server URL:<input type="text" id="url" value="127.0.0.1">
	Port:<input type="text" id="port" value="2459">
	<input type="button" value="Connect" id="connect">
	<br/><input type="checkbox" id="one_window_checkbox" checked onchange="one_window_checkbox_click()"> Show video and control in one window
	<br/><input type="checkbox" id="wireframe_checkbox" checked onchange="wireframe_checkbox_click()"> Show wireframe bounding box
	<br/><select id="stream_select" onchange="stream_select_click()">
		<option value="h264_vlc">H264 Stream (with vlc)</option>
		<option value="jpeg_vlc">JPEG Stream (with vlc)</option>
		<option value="h264_url">H264 Stream (only url)</option>
		<option value="jpeg_url">JPEG Stream (only url)</option>
		<option value="jpeg_raw">JPEG Stream (html5 only)</option>	
	</select> Select stream (before observing!)
</form>
<div id="status">Status: Not connected</div>
</p>
<table><tr>
<td id="video_td" valign="top">
	<!--canvas id="video" width="512" height="512" style="border:1px solid #000000;"></canvas-->
	<div id="video_container_div" style="position: relative;">
		<div id="video_div" style="position: relative; top: 0; left: 0;">
			<embed type="application/x-vlc-plugin" id="video" width="512" height="512" autoplay="no" controls="false" windowless="true"/>
			<div id="url_div" style="display:none;"></div><br/>
			<div id="functions_div"></div>
			<div id="weight_div"></div>
			<input type="checkbox" id="interpolation_checkbox" checked onchange="interpolation_checkbox_click()"> Interpolation<br/>
			<canvas id="transfer" width="412" height="16"></canvas>
			<table border="1"><tr id="transfer_form"></tr></table>
			<form>
				<input type="button" value="Pause" id="pause">
				<input type="button" value="Stop observing" id="stop">
				<input type="button" value="Stop simulation" id="exit">
			</form>
		</div>
		<div id="preview_div" style="position: absolute; top: 0; left: 0; opacity: 0.5;">
			<canvas id="preview" width="512" height="512" style="border:1px solid #000000;"></canvas>
		</div>
	</div>
<td>
<td id="preview_td" valign="top">
	<div id="preview_container_div" style="position: relative;">
	</div>
</td>
</tr></table>
<div id="list_td" style="display:none">
	<h3 id="isaac_name"></h3>
	<table id="list_table" border="1">
	<tr>
		<th>Name</th>
		<th>ID</th>
		<th>Nodes</th>
		<th>Max Functors</th>
		<th>Functors</th>
		<th>Dimension</th>
		<th>Sources</th>
		<th>Meta data</th>
		<th>Observe</th>
	</tr>
	</table>
	<div contentEditable="true" id="debug">Debug Infos</div>
</div>
</body>
<script>
/**
 * ISAAC Client - Reference client implementation for ISAAC
 *
 * @link    https://github.com/ComputationalRadiationPhysics/isaac
 * @license GPLv3
 * @author  Alexander Matthes
 */
var video = document.getElementById("video");
var preview = document.getElementById("preview");
var p_ctx = preview.getContext("2d");
var transfer = document.getElementById("transfer");
var t_ctx = transfer.getContext("2d");
var socket = null;
var observe_id = -1;
var particles = null;
var plugins = new Array();
var one_window = document.getElementById("one_window_checkbox").checked;
var wireframe = document.getElementById("wireframe_checkbox").checked;
var stream = document.getElementById("stream_select").selectedIndex;
var stream_img = new Image;
stream_img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==";

var functions = new Array();
var weight = new Array();

var projection = [
	1, 0, 0, 0,
	0, 1, 0, 0,
	0, 0, 1, 0,
	0, 0, 0, 1
];
var position = [
	0,
	0,
	0
];
var rotation = [
	1, 0, 0,
	0, 1, 0,
	0, 0, 1
];
var distance = 0;
var modelview = [
	1, 0, 0, 0,
	0, 1, 0, 0,
	0, 0, 1, 0,
	0, 0, 0, 1
];

var znear = 0;
var transfer_array = [];
var transfer_points = [];

var edges = [
	[ -1,  1,  1 ],
	[  1,  1,  1 ],
	[  1, -1,  1 ],
	[ -1, -1,  1 ],
	[ -1,  1, -1 ],
	[  1,  1, -1 ],
	[  1, -1, -1 ],
	[ -1, -1, -1 ]
];

function updateZNear()
{
	znear = projection[ 0] * preview.clientWidth / 2;
}

function mulMatrix( matrix1 , matrix2)
{
	var result = new Array(16);
	for (x = 0; x < 4; x++)
		for (y = 0; y < 4; y++)
			result[y+x*4] = matrix1[y+0*4] * matrix2[0+x*4]
			              + matrix1[y+1*4] * matrix2[1+x*4]
			              + matrix1[y+2*4] * matrix2[2+x*4]
			              + matrix1[y+3*4] * matrix2[3+x*4];
	return result;
}

function stream_is_raw( number )
{
	if (number >= 2 && number <=3)
		return true;
	return false;
}

function mulMatrix4(matrix,p)
{
	var t = new Array(4);
	t[0] =  matrix[ 0] * p[0] + matrix[ 4] * p[1] +  matrix[ 8] * p[2] + matrix[12] * p[3];
	t[1] =  matrix[ 1] * p[0] + matrix[ 5] * p[1] +  matrix[ 9] * p[2] + matrix[13] * p[3];
	t[2] =  matrix[ 2] * p[0] + matrix[ 6] * p[1] +  matrix[10] * p[2] + matrix[14] * p[3];
	t[3] =  matrix[ 3] * p[0] + matrix[ 7] * p[1] +  matrix[11] * p[2] + matrix[15] * p[3];
	return t;
}

function rotateMatrix( x, y, z, rad )
{
	//Rotation matrix:
	var s = Math.sin( rad * Math.PI / 360.0);
	var c = Math.cos( rad * Math.PI / 360.0);
	var l = Math.sqrt( x * x + y * y + z * z);
	if ( l == 0 )
		return;
	x = x / l;
	y = y / l;
	z = z / l;
	var rotate = new Array(9);
	rotate[0] = c + x * x * ( 1 - c );
	rotate[3] = x * y * ( 1 - c ) - z * s;
	rotate[6] = x * z * ( 1 - c ) + y * s;
	rotate[1] = y * x * ( 1 - c ) + z * s;
	rotate[4] = c + y * y * ( 1 - c );
	rotate[7] = y * z * ( 1 - c ) - x * s;
	rotate[2] = z * x * ( 1 - c ) - y * s;
	rotate[5] = z * y * ( 1 - c ) + x * s;
	rotate[8] = c + z * z * ( 1 - c );
	return rotate;
}

function mulMatrix3(matrix,p)
{
	return mulMatrix4(matrix,[p[0],p[1],p[2],1]);
}

function project(p)
{
	var m = mulMatrix4(projection,mulMatrix3(modelview,p));
	var t = new Array(2);
	t[0] = preview.clientWidth/2  + m[0] / m[3] * preview.clientWidth/2;
	t[1] = preview.clientHeight/2 + m[1] / m[3] * preview.clientHeight/2;
	t[2] = m[2] / m[3];
    return t;
}

function line(p1,p2)
{
	var t1 = project(p1);
	var t2 = project(p2);
	if ((Math.abs(t1[2]) > 1) || (Math.abs(t2[2]) > 1))
		return;
	p_ctx.moveTo( t1[0], t1[1] );
	p_ctx.lineTo( t2[0], t2[1] );
}

function point(p,nocheck = false)
{
	var t = project(p);
	if (!nocheck && Math.abs(t[2]) > 1)
		return;
	p_ctx.fillRect( t[0], t[1], 3, 3 );
}	


function drawUnitCube()
{
	//front
	line( edges[0], edges[1] );
	line( edges[1], edges[2] );
	line( edges[2], edges[3] );
	line( edges[3], edges[0] );
	//back
	line( edges[4], edges[5] );
	line( edges[5], edges[6] );
	line( edges[6], edges[7] );
	line( edges[7], edges[4] );
	//connetion
	line( edges[0], edges[4] );
	line( edges[1], edges[5] );
	line( edges[2], edges[6] );
	line( edges[3], edges[7] );
}

function redraw()
{
	//recalc modelview
	var position_m = [
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		position[0], position[1], position[2], 1
	];
	var rotation_m = [
		rotation[0], rotation[1], rotation[2], 0,
		rotation[3], rotation[4], rotation[5], 0,
		rotation[6], rotation[7], rotation[8], 0,
		0, 0, 0, 1
	];
	var distance_m = [
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, distance, 1
	];
	modelview = mulMatrix( distance_m, mulMatrix( rotation_m, position_m ) );
	
	if (stream == 4)
		p_ctx.drawImage(stream_img,0,0);
	else
		p_ctx.clearRect(0, 0, preview.clientWidth, preview.clientHeight);
	p_ctx.fillStyle = "#000000";
	if (one_window && !stream_is_raw( stream ))
	{
		if (stream == 4)
		{
			p_ctx.globalAlpha=0.5;
			p_ctx.strokeStyle = '#ffffff';
		}
		else
			p_ctx.strokeStyle = '#ffffff';
	}
	else
		p_ctx.strokeStyle = '#000000';
	p_ctx.lineWidth = 2;
	p_ctx.beginPath();
	
	if (wireframe)
		drawUnitCube();
	for (p in particles)
	{
		point( particles[p] );
	}
	p_ctx.stroke();
	p_ctx.globalAlpha=1.0;
}

var last_feedback_send = 0;
var sources = null;

function sendFeedback(name,feedback)
{
	var d = new Date();
		last_feedback_send = d.getTime();
	var obj =
	{
		"type" : "feedback",
		"observe id" : observe_id
	};
	obj[name] = feedback;
	socket.send(JSON.stringify(obj));
}

function mouseWheelHandler(e)
{
	document.body.style.overflowY = "hidden";
	var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail))) * 0.1;
	distance += delta;
	redraw();
	p_ctx.fillText("Delta: " + delta,1,10);
	sendFeedback("distance relative",delta);
}

var mousedown = [0,0,0];
var mousex = 0;
var mousey = 0;
function mouseDownHandler(e)
{
	mousedown[e.button] = 1;
	mousex = e.clientX;
	mousey = e.clientY;
}
function mouseUpHandler(e)
{
	mousedown[e.button] = 0;
}
function mouseResetHandler()
{
	mousedown[0] = 0;
	mousedown[1] = 0;
	mousedown[2] = 0;
}

function mouseMoveHandler(e)
{	
	var dx = e.clientX - mousex;
	var dy = e.clientY - mousey;
	var obj;
	if (mousedown[0])
	{
		var l = Math.sqrt( dx * dx + dy * dy );
		if (l > 0)
		{
			dx /= l;
			dy /= -l;
			var add = rotateMatrix(dy,dx,0,l);
			var result = new Array(9);
			for (x = 0; x < 3; x++)
				for (y = 0; y < 3; y++)
					result[y+x*3] = add[y+0*3] * rotation[0+x*3]
								  + add[y+1*3] * rotation[1+x*3]
								  + add[y+2*3] * rotation[2+x*3];
			rotation = result;
			//sendFeedback("rotation relative",add);
			sendFeedback("rotation axis",[dy, dx, 0, l]);
		}
	}
	if (mousedown[2] || mousedown[1])
	{
		var add = [dx/100, dy/100, 0];
		var add_p = [
			rotation[0] * add[0] + rotation[1] * add[1] + rotation[2] * add[2],
			rotation[3] * add[0] + rotation[4] * add[1] + rotation[5] * add[2],
			rotation[6] * add[0] + rotation[7] * add[1] + rotation[8] * add[2]
		];
		position[0] += add_p[0];
		position[1] += add_p[1];
		position[2] += add_p[2];
		sendFeedback("position relative",add);
	}
	redraw();
	mousex = e.clientX;
	mousey = e.clientY;
}

p_ctx.font = "10px Arial";
redraw();
preview.addEventListener("mousewheel", mouseWheelHandler, false);
preview.addEventListener("DOMMouseScroll", mouseWheelHandler, false);
preview.addEventListener("mousemove", mouseMoveHandler, false);
preview.addEventListener("mousedown", mouseDownHandler, false);
preview.addEventListener("mouseup", mouseUpHandler, false);
preview.onmouseout = function(){mouseResetHandler(); document.body.style.overflowY = "scroll";};

transfer.addEventListener("mousedown", transferMouseDownHandler, false);

document.getElementById("video_td").style.display = 'none';
document.getElementById("preview_td").style.display = 'none';

function stopObserverSimulation()
{
	if (observe_id < 0)
		return;
	var obj =
	{
		"type" : "stop",
		"observe id" : observe_id
	};
	socket.send(JSON.stringify(obj));
	observe_id = -1;
	var transfer_form = document.getElementById("transfer_form");
	while (transfer_form.firstChild) {
		transfer_form.removeChild(transfer_form.firstChild);
	}
}

function observeSimulation(id)
{
	stopObserverSimulation();
	observe_id = id;
	var connector_id = 0; //h264 rtp
	if (stream == 1 || stream == 3)
		connector_id = 1; //jpeg rtp
	if (stream == 4)
		connector_id = 2; //jpeg uri
	var obj =
	{
		"type" : "observe",
		"stream" : connector_id,
		"observe id" : observe_id
	};
	socket.send(JSON.stringify(obj));
}

function transferRectangle(x,y,w,h,color)
{
	t_ctx.beginPath();
	t_ctx.rect(x,y,w,h);
	t_ctx.fillStyle=color;
	t_ctx.fill();
}

var transfer_high = 64;

function transferMouseDownHandler(e)
{
	var rect = transfer.getBoundingClientRect();
	var X = Math.floor(e.clientX - rect.left);
	var Y = Math.floor(e.clientY - rect.top);
	var source = Math.floor(Y / (transfer_high+2));
	var value = Math.round(X / transfer.width * transfer_array[source].length);
	var localY = Math.floor(Y - source * (transfer_high+2));
	var element =
	{
		"value" : value,
		"r" : transfer_array[source][value][0]/255,
		"g" : transfer_array[source][value][1]/255,
		"b" : transfer_array[source][value][2]/255,
		"a" : 1-localY/(transfer_high+2)
	}
	transfer_points[source].push( element );
	sendFeedback( "transfer points", transfer_points );
}

function updateTransfer()
{
	transfer.width = video.width;
	transfer.height = transfer_array.length*transfer_high + (transfer_array.length - 1) * 2;
	for (var f = 0; f < transfer_array.length; f++)
	{
		var lastX = 0;
		for (var i = 0; i < transfer_array[f].length; i++)
		{
			var newX = Math.round( i* transfer.width / transfer_array[f].length );
			if (newX != lastX)
			{
				var bg1 = [127,127,127];
				var bg2 = [255,255,255];
				if (Math.round((lastX+transfer_high/4) / (transfer_high/2)) % 2 == 0)
				{
					var bgt = bg1;
					bg1 = bg2;
					bg2 = bgt;
				}
				var rgba = transfer_array[f][i];
				var fg1 = new Array(3);
				fg1[0] = Math.round((rgba[0] * rgba[3] + bg1[0] * (255 - rgba[3]) )/ 255);
				fg1[1] = Math.round((rgba[1] * rgba[3] + bg1[1] * (255 - rgba[3]) )/ 255);
				fg1[2] = Math.round((rgba[2] * rgba[3] + bg1[2] * (255 - rgba[3]) )/ 255);
				var fg2 = new Array(3);
				fg2[0] = Math.round((rgba[0] * rgba[3] + bg2[0] * (255 - rgba[3]) )/ 255);
				fg2[1] = Math.round((rgba[1] * rgba[3] + bg2[1] * (255 - rgba[3]) )/ 255);
				fg2[2] = Math.round((rgba[2] * rgba[3] + bg2[2] * (255 - rgba[3]) )/ 255);
				transferRectangle(lastX,f*(transfer_high+2)                ,newX-lastX,transfer_high/2,"rgb("+ fg1[0] +","+ fg1[1] +","+ fg1[2] +")");
				transferRectangle(lastX,f*(transfer_high+2)+transfer_high/2,newX-lastX,transfer_high/2,"rgb("+ fg2[0] +","+ fg2[1] +","+ fg2[2] +")");
			}
			lastX = newX;
		}
		t_ctx.beginPath();
		var first = true;
		for (p in transfer_points[f])
		{
			var point = [
				transfer_points[f][p].value * transfer.width / transfer_array[f].length,
				f*(transfer_high+2) + transfer_high - transfer_points[f][p].a * transfer_high
			];
			if (first)
			{
				t_ctx.moveTo( point[0], point[1] );
				first = false;
			}
			else
				t_ctx.lineTo( point[0], point[1] );
		}
		t_ctx.stroke();
		transferRectangle(0,f*(transfer_high+2)+transfer_high,transfer.width,2,"black");
	}
}

function removePoint( e )
{
	var elements = e.target.id.split("_");
	var s = parseInt(elements[1]);
	var i = parseInt(elements[2]);
	transfer_points[s].splice( i, 1 );
	sendFeedback( "transfer points", transfer_points );
}

function pad(num, size) {
    var s = num.toString();
    var l = size - s.length;
    for (var i = 0; i < l; i++)
		s =	"&nbsp;" + s;
    return s;
}

function createWeightFeedback( w, range_name, value_name )
{
	return function()
	{
		var myself = document.getElementById( range_name );
		weight[w] = (myself.value/100)*(myself.value/100);
		var value = document.getElementById( value_name );
		if ( weight[w] == 0 )
			value.innerHTML = ' <b><font color="red">Off</font></b> ';
		else
			value.innerHTML = ' <b><font color="green">' + weight[w].toFixed(1) + '</font></b> ';
	};
}

document.getElementById("connect").onclick = function()
{
	if (socket != null && socket.readyState == 1)
	{
		socket.send(JSON.stringify({"type" : "closed"}));
		socket.close();
		socket.onclose();
	}
	else //Open
	{
		url = "ws://" + document.getElementById("url").value + ":" + document.getElementById("port").value;
		if (typeof MozWebSocket != "undefined")
			socket = new MozWebSocket( url , "isaac-json-protocol" );
		else
			socket = new WebSocket( url , "isaac-json-protocol" );
		try
		{
			socket.onopen = function()
			{
				document.getElementById("status").textContent = "Status: Connected";
				document.getElementById("connect").value = "Close";
			};
			socket.onmessage = function got_packet(msg)
			{
				var obj = JSON.parse(msg.data);
				if (obj["type"] == "hello")
				{
					document.getElementById("isaac_name").textContent = obj["name"];
					var table = document.getElementById("list_table");
					while (table.rows.length > 1)
						table.deleteRow(1);
					document.getElementById("list_td").style.display = 'initial';
				}
				if (obj["type"] == "register")
				{
					plugins.push(obj);
					var table = document.getElementById("list_table");					
					var row = table.insertRow(-1);
					row.id = obj["id"];
					row.insertCell(0).innerHTML = obj["name"];
					row.insertCell(1).innerHTML = obj["id"];
					row.insertCell(2).innerHTML = obj["nodes"];
					row.insertCell(3).innerHTML = obj["max functors"];

					var cell = row.insertCell(4);
					for (element in obj["functors"])
					{
						var e = obj["functors"][element]
						cell.innerHTML += "<b>" + e["name"] + ":</b> ";
						cell.innerHTML += e["description"] + "<br/>";
					}
					var cell = row.insertCell(5);
					var d = obj["dimension"];
					cell.innerHTML += obj["width"];
					if (d > 1)
						cell.innerHTML += " * " + obj["height"];
					if (d > 2)
						cell.innerHTML += " * " + obj["depth"];
					var cell = row.insertCell(6);
					for (element in obj["sources"])
					{
						var e = obj["sources"][element]
						cell.innerHTML += "<b>" + e["name"] + ":</b><br/>";
						cell.innerHTML += " Feature dimension(" + e["feature dimension"] + ")<br/>";
					}
					var cell = row.insertCell(7);//.innerHTML = obj["metadata"].toSource();
					for (element in obj["metadata"])
					{
						cell.innerHTML += "<b>" + element + ":</b> ";
						cell.innerHTML += obj["metadata"][element];
						cell.innerHTML += "<br/>";
					}
					var observeCell = row.insertCell(8);
					var button = document.createElement("input");
					button.type = "button";
					button.value = "Observe";
					button.onclick = function()
					{
						var global_size = [ obj["width"],  obj["height"], obj["depth"] ];
						var m = Math.max( global_size[0], global_size[1], global_size[2] );
						edges = [
							[ -global_size[0] / m,  global_size[1] / m,  global_size[2] / m ],
							[  global_size[0] / m,  global_size[1] / m,  global_size[2] / m ],
							[  global_size[0] / m, -global_size[1] / m,  global_size[2] / m ],
							[ -global_size[0] / m, -global_size[1] / m,  global_size[2] / m ],
							[ -global_size[0] / m,  global_size[1] / m, -global_size[2] / m ],
							[  global_size[0] / m,  global_size[1] / m, -global_size[2] / m ],
							[  global_size[0] / m, -global_size[1] / m, -global_size[2] / m ],
							[ -global_size[0] / m, -global_size[1] / m, -global_size[2] / m ]
						];
						document.getElementById("video_td").style.display = 'table-cell';
						document.getElementById("preview_td").style.display = 'table-cell';
						document.getElementById("debug").textContent = "Debug Infos";
						projection = obj["projection"];
						position = obj["position"];
						distance = obj["distance"];
						rotation = obj["rotation"];
						sources = obj["sources"];
						document.getElementById("interpolation_checkbox").checked = obj["interpolation"];
						
						preview.width = obj["framebuffer width"];
						preview.height = obj["framebuffer height"];
						video.width = obj["framebuffer width"];
						video.height = obj["framebuffer height"];
						if (!stream_is_raw( stream ))
							video.playlist.items.clear();
						observeSimulation(obj["id"]);
						redraw();
					};
					observeCell.appendChild(button);
				}
				if (obj["type"] == "register video")
				{
					var url = "http://" + document.getElementById("url").value + ":" + document.getElementById("port").value + "/" + obj["connector"] + "/" + obj["name"] + "/" + obj["reference"];
					if (stream_is_raw( stream ))
						document.getElementById("url_div").textContent =  url;
					else
					{
						video.playlist.add( url, "Visualization", ["--network-caching 1", "--live-caching 1", "--disk-caching 1", "--file-caching 1"] );
						video.playlist.play();
					}
				}
				if (obj["type"] == "period" || obj["type"] == "update")
				{
					if (obj.hasOwnProperty("metadata"))
					{
						if (obj["metadata"].hasOwnProperty("reference particles"))
							particles = obj["metadata"]["reference particles"];
						document.getElementById("debug").innerHTML = JSON.stringify(obj["metadata"]).replace(/{/g,"<br/>{").replace(/}/g,"}<br/>");
					}
					var d = new Date();
					var	now = d.getTime();
					if (now - last_feedback_send > 100)
					{
						if (obj.hasOwnProperty("projection"))
							projection = obj["projection"];
						if (obj.hasOwnProperty("position"))
							position = obj["position"];
						if (obj.hasOwnProperty("rotation"))
							rotation = obj["rotation"];
						if (obj.hasOwnProperty("distance"))
							distance = obj["distance"];
						if (obj.hasOwnProperty("interpolation"))
							document.getElementById("interpolation_checkbox").checked = obj["interpolation"];
					}
					if (obj.hasOwnProperty("functions"))
					{
						var functions_div = document.getElementById("functions_div");
						while (functions_div.firstChild) {
							functions_div.removeChild(functions_div.firstChild);
						}
						functions = obj["functions"];
						for (var f in functions)
						{
							var title = document.createElement("SPAN");
							title.innerHTML = sources[f].name + " function: ";
							functions_div.appendChild(title);
							var function_string = document.createElement("INPUT");
							function_string.value = functions[f].source;
							function_string.size = 80;
							function_string.id = "f_" + f + "_string";
							functions_div.appendChild(function_string);
							var error = document.createElement("SPAN");
							switch (functions[f].error)
							{
								case 0:
									error.innerHTML = ' <b><font color="green">Ok</font></b>';
									break;
								case 1:
									error.innerHTML = ' <b><font color="orange">Too much functors, ignoring at least one</font></b>';
									break;
								case 2:
									error.innerHTML = ' <b><font color="orange">Too much parameters, ignoring at least one</font></b>';
									break;
								case -1:
									error.innerHTML = ' <b><font color="red">Missing )</font></b>';
									break;
								case -2:
									error.innerHTML = ' <b><font color="red">Unknown functor</font></b>';
									break;
								default:
									error.innerHTML = ' <b><font color="red">Fatal error</font></b>';
							}
							functions_div.appendChild(error);
							functions_div.appendChild(document.createElement("BR"));
						}
						var function_button = document.createElement("INPUT");
						function_button.type = "button";
						function_button.value = "Update functions";
						function_button.id = "f_button";
						function_button.onclick = function()
						{
							for (var f in functions)
								functions[f] = document.getElementById("f_" + f + "_string").value;
							sendFeedback( "functions", functions );
						};
						functions_div.appendChild(function_button);
					}
					if (obj.hasOwnProperty("weight"))
					{
						var weight_div = document.getElementById("weight_div");
						while (weight_div.firstChild) {
							weight_div.removeChild(weight_div.firstChild);
						}
						weight = obj["weight"];
						for (var w in weight)
						{
							var title = document.createElement("SPAN");
							title.innerHTML = sources[w].name + ": ";
							weight_div.appendChild(title);
							var weight_range = document.createElement("INPUT");
							weight_range.type = "range";
							weight_range.min = 0;
							weight_range.max = 316;
							weight_range.value = Math.floor(Math.sqrt(weight[w])*100);
							var range_name = "w_" + w + "_range";
							var value_name = "w_" + w + "_value";
							weight_range.id = range_name
							weight_range.oninput = createWeightFeedback( w, range_name, value_name );
							weight_div.appendChild(weight_range);
							var value = document.createElement("SPAN");
							if ( weight[w] == 0 )
								value.innerHTML = ' <b><font color="red">Off</font></b> ';
							else
								value.innerHTML = ' <b><font color="green">' + weight[w].toFixed(1) + '</font></b> ';
							value.id = value_name;
							weight_div.appendChild(value);
						}
						var weight_button = document.createElement("INPUT");
						weight_button.type = "button";
						weight_button.value = "Update weights";
						weight_button.id = "w_button";
						weight_button.onclick = function()
						{
							sendFeedback( "weight", weight );
						};
						weight_div.appendChild(weight_button);
					}
					if (obj.hasOwnProperty("transfer array"))
					{
						transfer_array = obj["transfer array"];
						if (obj.hasOwnProperty("transfer points"))
						{
							transfer_points = obj["transfer points"];
							var transfer_form = document.getElementById("transfer_form");
							while (transfer_form.firstChild) {
								transfer_form.removeChild(transfer_form.firstChild);
							}
							for (var s in transfer_points)
							{
								var node = document.createElement("TD");
								node.innerHTML = "<b>" + sources[s].name + "</b>";
								node.style.vertical_align = "bottom";
								for (var i in transfer_points[s])
								{
									var subnode = document.createElement("DIV");
									subnode.innerHTML = '<font face="monospace">' + (transfer_points[s][i].value / transfer_array[s].length).toFixed(3) + ": </font>";
									var input = document.createElement("INPUT");
									input.type = button;
									var picker = new jscolor(input);
									input.jscolor = picker;
									picker.closable = true;
									picker.closeText = "Close";
									picker.fromRGB( transfer_points[s][i].r * 255, transfer_points[s][i].g * 255, transfer_points[s][i].b * 255 );
									input.id = "p_" + s + "_" + i + "_color";
									subnode.appendChild(input);
									var alpha = document.createElement("INPUT");
									alpha.value = transfer_points[s][i].a;
									alpha.size = 10;
									alpha.id = "p_" + s + "_" + i + "_alpha";
									subnode.appendChild(alpha);
									if (i != 0 && i != transfer_points[s].length-1)
									{
										var remove = document.createElement("INPUT");
										remove.type = "button";
										remove.value = "Remove";
										remove.id = "p_" + s + "_" + i + "_remove";
										remove.onclick = removePoint;
										subnode.appendChild(remove);
									}
									node.appendChild(subnode);
								}
								transfer_form.appendChild(node);
							}
							var node = document.createElement("TD");
							node.innerHTML = "<b> Controls </b><br/>";
							var redo = document.createElement("INPUT");
							redo.type = "button";
							redo.value = "Reset";
							redo.onclick = function ()
							{
								sendFeedback("request", "transfer");
							};
							node.appendChild(redo);
							var submit = document.createElement("INPUT");
							submit.type = "button";
							submit.value = "Submit changes";
							submit.onclick = function()
							{
								for (var s in transfer_points)
									for (var i in transfer_points[s])
									{
										var base = "p_" + s + "_" + i;
										var color = document.getElementById( base + "_color");
										var alpha = document.getElementById( base + "_alpha");
										transfer_points[s][i].r = color.jscolor.rgb[0]/255;
										transfer_points[s][i].g = color.jscolor.rgb[1]/255;
										transfer_points[s][i].b = color.jscolor.rgb[2]/255;
										transfer_points[s][i].a = parseFloat(alpha.value);
									}
								sendFeedback( "transfer points", transfer_points );
							};
							node.appendChild(submit);
							transfer_form.appendChild(node);
						}
						updateTransfer();
					}
					redraw();
				}
				if (obj["type"] == "exit")
				{
					var table = document.getElementById("list_table");					
					for (var c = 1; c < table.rows.length;c++)
						if (table.rows[c].id == obj["id"])
						{
							table.deleteRow(c);
							break;
						}
					if (observe_id == obj["id"])
					{
						document.getElementById("video_td").style.display = 'none';
						document.getElementById("preview_td").style.display = 'none';
						video.playlist.stop();
					}
				}
				if (obj["type"] == "period video")
				{
					stream_img.src = obj["payload"];
				}
			};
			socket.onclose = function()
			{
				if (document.getElementById("status").textContent != "Status: An error occured. Wrong address, network gone or server not started?")
					document.getElementById("status").textContent = "Status: Closed";
				document.getElementById("connect").value = "Connect";
				document.getElementById("list_td").style.display = 'none';
				document.getElementById("video_td").style.display = 'none';
				document.getElementById("preview_td").style.display = 'none';
			};
			socket.onerror = function()
			{
				document.getElementById("status").textContent = "Status: An error occured. Wrong address, network gone or server not started?";
			};
		}
		catch(exception)
		{
			document.getElementById("status").textContent = "Status: Error" + exception;
		}
	}
};

document.getElementById("stop").onclick = function()
{
	document.getElementById("video_td").style.display = 'none';
	document.getElementById("preview_td").style.display = 'none';
	stopObserverSimulation();
}

document.getElementById("pause").onclick = function()
{
	var obj =
	{
		"type" : "feedback",
		"observe id" : observe_id,
		"metadata" :
		{
			"pause" : true
		}
	};
	socket.send(JSON.stringify(obj));
}

document.getElementById("exit").onclick = function()
{
	var obj =
	{
		"type" : "feedback",
		"observe id" : observe_id,
		"metadata" :
		{
			"exit" : 1
		}
	};
	socket.send(JSON.stringify(obj));
	document.getElementById("stop").onclick();
}

function one_window_checkbox_click()
{
	one_window = document.getElementById("one_window_checkbox").checked;
	if (one_window)
	{
		var node = document.getElementById("preview_div");
		document.getElementById("video_container_div").appendChild(node);
		redraw();
	}
	else
	{
		var node = document.getElementById("preview_div");
		document.getElementById("preview_container_div").appendChild(node);
		redraw();
	}
};

function wireframe_checkbox_click()
{
	wireframe = document.getElementById("wireframe_checkbox").checked;
};

function interpolation_checkbox_click()
{
	var status = document.getElementById("interpolation_checkbox").checked;
	sendFeedback( "interpolation", status );
};

function stream_select_click()
{
	stream = document.getElementById("stream_select").selectedIndex;
	if ( stream_is_raw( stream ) )
	{
		document.getElementById("video").style.display = 'none';
		document.getElementById("url_div").style.display = 'inline';
		document.getElementById("preview_div").style.position = 'static';
	}
	else
	{
		document.getElementById("video").style.display = 'inline';
		document.getElementById("url_div").style.display = 'none';
		document.getElementById("preview_div").style.position = 'absolute';
		document.getElementById("preview_div").style.top = '0';
		document.getElementById("preview_div").style.left = '0';
		if (stream == 4)
			document.getElementById("preview_div").style.opacity = '1.0';
		else
			document.getElementById("preview_div").style.opacity = '0.5';
	}
};

</script>
</html>
